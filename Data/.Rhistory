) %>%
mutate(
state_a = as.numeric(state_a),
county_a = as.numeric(county_a)
)
link_merge <- left_join(links,acs_data_a)
View(link_merge)
acs_data_b <- acs_data %>% rename(
state_b = state_fips,
county_b = county_fips,
county_state_fips_b = county_state_fips,
median_home_value_b = median_home_value,
median_individual_income_b = median_individual_income,
total_population_b = total_population,
share_workers_in_naics_72_b = share_workers_in_naics_72,
share_population_high_school_diploma_b = share_population_high_school_diploma,
share_population_degree_b = share_population_degree
) %>%
mutate(
state_b = as.numeric(state_b),
county_b = as.numeric(county_b)
)
link_merge <- left_join(links,acs_data_a) %>% left_join(acs_data_b)
View(link_merge)
names(link_merge)
View(links)
### Remember that the flow is from b to a
### so if the home_value gap is positive it means that the destination home value is higher than the origin home value
link_merge <- left_join(links,acs_data_a) %>%
left_join(acs_data_b) %>%
mutate(same_county_type = as.integer(county_type_a == county_type_b),
same_division = as.integer(division_a == division_b),
same_state = as.integer(state_a == state_b),
home_value_gap = median_home_value_a - median_home_value_b,
income_gap = median_individual_income_a - median_individual_income_b,
population_gap = total_population_a - total_population_b,
naics_72_gap = share_workers_in_naics_72_a - share_workers_in_naics_72_b,
high_school_gap = share_population_high_school_diploma_a - share_population_high_school_diploma_b,
bachelor_gap = share_population_degree_a - share_population_degree_a) %>%
select(state_a, county_a, state_b, county_b,
agi_net, individual_net, returns_net,
same_county_type,same_division,same_state,
home_value_gap, income_gap, population_gap,
naics_72_gap, high_school_gap,bachelor_gap)
View(link_merge)
# Fit a Poisson regression model
fit <- glm(returns_net ~ same_county_type + same_division + same_state, data = link_merge, family = poisson)
# Display the model summary
summary(fit)
View(link_merge)
# Fit a Poisson regression model
fit <- glm(agi_net ~ same_county_type + same_division + same_state, data = link_merge, family = poisson)
# Display the model summary
summary(fit)
# Fit a Poisson regression model
fit <- glm(agi_net ~ same_county_type + same_division + same_state + home_value_gap + income_gap + population_gap + naics_72_gap + high_school_gap + bachelor_gap, data = link_merge, family = poisson)
# Display the model summary
summary(fit)
# Exponentiate coefficients to get rate ratios
exp(coef(fit))
# Load the tidycensus package
library(tidycensus)
# Set your Census API key
# census_api_key("your_census_api_key_here", install = TRUE)
# Define the variable for Median Value of Owner-Occupied Housing Units
var_code_for_median_home_value <- "B25077_001E"
# Fetch the data
median_home_value_data <- get_acs(
geography = "state",
variables = var_code_for_median_home_value,
year = 2021,
survey = "acs5" # American Community Survey 5-Year Estimates
)
# View the data
head(median_home_value_data)
View(median_home_value_data)
# Fetch the data
median_home_value_data <- get_acs(
geography = "state",
variables = var_code_for_median_home_value,
year = 2021,
survey = "acs1" # American Community Survey 5-Year Estimates
)
View(median_home_value_data)
install.packages("timevis")
# 1. Install and load the necessary package
if (!requireNamespace("timevis", quietly = TRUE)) {
install.packages("timevis")
}
library(timevis)
# 2. Create data for the timeline
# Define the date ranges and corresponding text
data <- data.frame(
id      = 1:3,
content = c("Event 1", "Event 2", "Event 3"),
start   = as.Date(c("2016-01-01", "2018-01-01", "2020-01-01")),
end     = as.Date(c("2017-01-01", "2019-01-01", "2021-01-01"))
)
# 3. Create the timeline and render it
timeline <- timevis(data)
# Set timeline window range to display from January 2016 to April 2024
setWindow(timeline, start = "2016-01-01", end = "2024-04-30")
# Print the timeline
timeline
# 2. Create data for the timeline
# Define the date ranges and corresponding text
data <- data.frame(
id      = 1:3,
content = c("TCJA - Doubled the <br>maximum per child credit amount from $1,000 to $2,000", "Event 2", "Event 3"),
start   = as.Date(c("2016-01-01", "2018-01-01", "2020-01-01")),
end     = as.Date(c("2017-01-01", "2019-01-01", "2021-01-01"))
)
# 3. Create the timeline and render it
timeline <- timevis(data)
# Set timeline window range to display from January 2016 to April 2024
setWindow(timeline, start = "2016-01-01", end = "2024-04-30")
# 2. Create data for the timeline
# Define the date ranges and corresponding text
data <- data.frame(
id      = 1:3,
content = c("TCJA - Doubled the <br>maximum per child credit amount <br>from $1,000 to $2,000", "Event 2", "Event 3"),
start   = as.Date(c("2016-01-01", "2018-01-01", "2020-01-01")),
end     = as.Date(c("2017-01-01", "2019-01-01", "2021-01-01"))
)
# 3. Create the timeline and render it
timeline <- timevis(data)
# Set timeline window range to display from January 2016 to April 2024
setWindow(timeline, start = "2016-01-01", end = "2024-04-30")
# 2. Create data for the timeline
# Define the date ranges and corresponding text
data <- data.frame(
id      = 1:3,
content = c("TCJA's CTC",
"ARP's CTC",
"TCJA's CTC",
"Enhanced CTC Proposal"),
start   = as.Date(c("2018-01-01", "2021-03-11", "2022-01-01","2024-01-16")),
end     = as.Date(c("2021-03-10", "2021-12-30", "2024-02-01","2024-02-01"))
)
# 3. Create the timeline and render it
timeline <- timevis(data)
# Set timeline window range to display from January 2016 to April 2024
setWindow(timeline, start = "2016-01-01", end = "2024-04-30")
# Print the timeline
timeline
# Define the date ranges and corresponding text
data <- data.frame(
id      = 1:3,
content = c("TCJA's CTC",
"ARP's CTC",
"TCJA's CTC",
"Enhanced CTC Proposal"),
start   = as.Date(c("2018-01-01", "2021-03-11", "2022-01-01","2024-01-16")),
end     = as.Date(c("2021-03-10", "2021-12-30", "2024-02-01","2024-02-01"))
)
# 2. Create data for the timeline
# Define the date ranges and corresponding text
data <- data.frame(
id      = 1:4,
content = c("TCJA's CTC",
"ARP's CTC",
"TCJA's CTC",
"Enhanced CTC Proposal"),
start   = as.Date(c("2018-01-01", "2021-03-11", "2022-01-01","2024-01-16")),
end     = as.Date(c("2021-03-10", "2021-12-30", "2024-02-01","2024-02-01"))
)
# 3. Create the timeline and render it
timeline <- timevis(data)
# Set timeline window range to display from January 2016 to April 2024
setWindow(timeline, start = "2016-01-01", end = "2024-04-30")
View(data)
# 2. Create data for the timeline
# Define the date ranges and corresponding text
data <- data.frame(
id      = 1:4,
content = c("TCJA's CTC",
"ARP's CTC",
"TCJA's CTC Return",
"Enhanced CTC Proposal"),
start   = as.Date(c("2018-01-01", "2021-03-11", "2022-01-01","2024-01-16")),
end     = as.Date(c("2021-03-10", "2021-12-30", "2024-02-01","2024-02-01"))
)
# 3. Create the timeline and render it
timeline <- timevis(data)
# Set timeline window range to display from January 2016 to April 2024
setWindow(timeline, start = "2016-01-01", end = "2024-04-30")
# 2. Create data for the timeline
# Define the date ranges and corresponding text
data <- data.frame(
id      = 1:4,
content = c("TCJA's CTC",
"ARP's CTC",
"TCJA's CTC Return",
"Enhanced CTC Proposal?"),
start   = as.Date(c("2018-01-01", "2021-03-11", "2022-01-01","2024-01-16")),
end     = as.Date(c("2021-03-10", "2021-12-30", "2024-02-01","2025-01-01"))
)
# 3. Create the timeline and render it
timeline <- timevis(data)
# Set timeline window range to display from January 2016 to April 2024
setWindow(timeline, start = "2016-01-01", end = "2024-04-30")
# Set timeline window range to display from January 2016 to April 2024
setWindow(timeline, start = "2018-01-01", end = "2024-04-30")
# 2. Create data for the timeline
# Define the date ranges and corresponding text
data <- data.frame(
id      = 1:4,
content = c("TCJA's CTC",
"ARP's CTC",
"TCJA's CTC Return",
"Enhanced <br>CTC Proposal?"),
start   = as.Date(c("2018-01-01", "2021-03-11", "2022-01-01","2024-01-16")),
end     = as.Date(c("2021-03-10", "2021-12-30", "2024-02-01","2025-01-01"))
)
# 3. Create the timeline and render it
timeline <- timevis(data)
# Set timeline window range to display from January 2016 to April 2024
setWindow(timeline, start = "2018-01-01", end = "2024-04-30")
# Set timeline window range to display from January 2016 to April 2024
setWindow(timeline, start = "2018-01-01", end = "2025-01-01")
timevis(data)
?timevis
# 2. Create data for the timeline
# Define the date ranges and corresponding text
data <- data.frame(
id      = 1:4,
content = c("TCJA's<br>CTC",
"ARP's<br>CTC",
"TCJA's<br>CTC Return",
"Enhanced<br>CTC Proposal?"),
start   = as.Date(c("2018-01-01", "2021-03-11", "2022-01-01","2024-01-16")),
end     = as.Date(c("2021-03-10", "2021-12-30", "2024-02-01","2025-01-01"))
)
# 3. Create the timeline and render it
timeline <- timevis(data,)
# Set timeline window range to display from January 2016 to April 2024
setWindow(timeline, start = "2018-01-01", end = "2025-01-01")
# Print the timeline
timeline
# 3. Create the timeline and render it
timeline <- timevis(data,showZoom = FALSE)
# Set timeline window range to display from January 2016 to April 2024
setWindow(timeline, start = "2018-01-01", end = "2025-01-01")
# Print the timeline
timeline
# Ben Glasner
# Median Hourly Earnings of the labor force
# Load the required libraries
library(dplyr)
library(plotly)
library(tidyr)
# Create a dataframe with 10000 rows
data <- tibble(ID = 1:10000)
# Define the Wage variable
data <- data %>%
mutate(Wage = ifelse(ID <= 9000, sample(10:50, size = n(), replace = TRUE), 0))
# Define shock variables
data <- data %>%
mutate(shock_1 = rbinom(n(), 1, 0.15),
shock_2 = ifelse(Wage < 25, rbinom(n(), 1, 0.2), rbinom(n(), 1, 0.05)),
shock_3 = ifelse(Wage < 25, rbinom(n(), 1, 0.05), rbinom(n(), 1, 0.2)))
# Calculate mean and median Wage under different scenarios
scenarios <- list(
No_Shock = data %>%
mutate(Wage_nocomp = ifelse(Wage == 0, NA, Wage)) %>%
summarize(mean_lf_earnings = mean(Wage),
median_lf_earnings = median(Wage),
mean_wage = mean(Wage_nocomp, na.rm = TRUE),
median_wage = median(Wage_nocomp, na.rm = TRUE)),
Shock_1 = data %>%
mutate(Wage = ifelse(shock_1 == 1, 0, Wage),
Wage_nocomp = ifelse(Wage == 0, NA, Wage)) %>%
summarize(mean_lf_earnings = mean(Wage),
median_lf_earnings = median(Wage),
mean_wage = mean(Wage_nocomp, na.rm = TRUE),
median_wage = median(Wage_nocomp, na.rm = TRUE)),
Shock_2 = data %>%
mutate(Wage = ifelse(shock_2 == 1, 0, Wage),
Wage_nocomp = ifelse(Wage == 0, NA, Wage)) %>%
summarize(mean_lf_earnings = mean(Wage),
median_lf_earnings = median(Wage),
mean_wage = mean(Wage_nocomp, na.rm = TRUE),
median_wage = median(Wage_nocomp, na.rm = TRUE)),
Shock_3 = data %>%
mutate(Wage = ifelse(shock_3 == 1, 0, Wage),
Wage_nocomp = ifelse(Wage == 0, NA, Wage)) %>%
summarize(mean_lf_earnings = mean(Wage),
median_lf_earnings = median(Wage),
mean_wage = mean(Wage_nocomp, na.rm = TRUE),
median_wage = median(Wage_nocomp, na.rm = TRUE)
))
# Convert the scenarios list to a dataframe for plotting
scenarios_df <- bind_rows(scenarios, .id = "Scenario") %>%
pivot_longer(-Scenario, names_to = "Statistic", values_to = "Value") %>%
filter(Statistic %in% c("median_lf_earnings","median_wage")) %>%
mutate(Shock_type = case_when(
Scenario == "No_Shock" ~ "No Employment Shock Occurs. <br>1,000 people have a wage of $0 <br>and $9,000 have a wage between $10 and $50",
Scenario == "Shock_1" ~ "Uniform 15% chance for anyone <br>to go from their origional wage to $0",
Scenario == "Shock_2" ~ "20% chance for those with a wage <br>less than $25 and 5% chance for <br>those with wages greater than $25 to <br>go from their origional wage to $0",
Scenario == "Shock_3" ~ "5% chance for those with a wage <br>less than $25 and 20% chance for <br>those with wages greater than $25 to <br>go from their origional wage to $0",
TRUE ~ NA
))
# Create the Plotly scatter plot
p <- plot_ly(data = scenarios_df,
x = ~Scenario,
y = ~Value,
type = 'scatter',
mode = 'markers',
color = ~ Statistic,
text = ~paste("Scenario:", Scenario, "<br>", "Statistic:", Statistic, "<br>", "Value:", Value, "<br>", Shock_type),
hoverinfo = 'text') %>%
layout(title = "Wage Statistics Across Different Shock Scenarios",
xaxis = list(title = "Statistic"),
yaxis = list(title = "Value"))
p
# summary statistics on matching, participation, access
rm(list = ls())
###########################
###   Load Packages     ###
###########################
library(haven)
library(dplyr)
library(plotly)
library(tidyr)
library(openxlsx)
#################
### Set paths ###
#################
# Define user-specific project directories
project_directories <- list(
"bglasner" = "C:/Users/bglasner/EIG Dropbox/Benjamin Glasner/GitHub/Retirement-data-summary-2024",
"bngla" = "C:/Users/bngla/EIG Dropbox/Benjamin Glasner/GitHub/Retirement-data-summary-2024",
"Benjamin Glasner" = "C:/Users/Benjamin Glasner/EIG Dropbox/Benjamin Glasner/GitHub/Retirement-data-summary-2024",
"sarah" = "/Users/sarah/Library/CloudStorage/GoogleDrive-sarah@eig.org/My Drive/projects/retirement"
)
# Setting project path based on current user
current_user <- Sys.info()[["user"]]
if (!current_user %in% names(project_directories)) {
stop("Root folder for current user is not defined.")
}
path_project <- project_directories[[current_user]]
path_data = file.path(path_project, "Data")
path_output = file.path(path_project, "Output")
# Set working directory for SIPP data
setwd(path_data)
sipp_2023 = read.csv("sipp_2023_wrangled.csv")
###################################################
## Access, Participation, and Matching - overall ##
###################################################
# access
sipp_2023 %>%
filter(in_age_range =="yes") %>%
filter(FULL_PART_TIME=="full time") %>%
rename(`Has access to an Employer Retirement Plan`=ANY_RETIREMENT_ACCESS) %>%
group_by(`Has access to an Employer Retirement Plan`) %>%
summarise(count = sum(WPFINWGT)) %>%
ungroup() %>%
mutate(Share = count / sum(count)*100) %>%
select(-c(count))
# participate
sipp_2023 %>%
filter(in_age_range =="yes") %>%
filter(FULL_PART_TIME=="full time") %>%
filter(PARTICIPATING!="Missing") %>%
rename(`Participates in Employer Retirement Plan` = PARTICIPATING)
group_by(`Participates in Employer Retirement Plan`) %>%
summarise(count = sum(WPFINWGT)) %>%
ungroup() %>%
mutate(Share = count / sum(count)*100) %>%
select(-c(count))
sipp_2023 %>%
filter(in_age_range =="yes") %>%
filter(FULL_PART_TIME=="full time") %>%
filter(MATCHING!="Missing") %>%
rename(`Employer contributes to Employer Retirement Plan`=MATCHING) %>%
group_by(`Employer contributes to Employer Retirement Plan`) %>%
summarise(count = sum(WPFINWGT)) %>%
ungroup() %>%
mutate(Share = count / sum(count)*100) %>%
select(-c(count))
group_by(`Participates in Employer Retirement Plan`) %>%
summarise(count = sum(WPFINWGT)) %>%
ungroup() %>%
mutate(Share = count / sum(count)*100) %>%
select(-c(count))
sipp_2023 %>%
filter(in_age_range =="yes") %>%
filter(FULL_PART_TIME=="full time") %>%
filter(PARTICIPATING!="Missing") %>%
rename(`Participates in Employer Retirement Plan` = PARTICIPATING) %>%
group_by(`Participates in Employer Retirement Plan`) %>%
summarise(count = sum(WPFINWGT)) %>%
ungroup() %>%
mutate(Share = count / sum(count)*100) %>%
select(-c(count))
sipp_2023 %>%
filter(in_age_range =="yes") %>%
filter(FULL_PART_TIME=="full time") %>%
rename(`Has access to an Employer Retirement Plan`=ANY_RETIREMENT_ACCESS) %>%
group_by(`Has access to an Employer Retirement Plan`) %>%
summarise(count = sum(WPFINWGT)) %>%
ungroup() %>%
mutate(Share = count / sum(count)*100) %>%
select(-c(count))
ACCESS_decile = sipp_2023 %>%
filter(in_age_range =="yes") %>%
mutate(INCOME_DECILE = ntile(TFTOTINC, 10)) %>%
filter(FULL_PART_TIME=="full time") %>%
group_by(ANY_RETIREMENT_ACCESS, INCOME_DECILE) %>%
summarise(count = sum(WPFINWGT)) %>%
ungroup() %>%
group_by(INCOME_DECILE) %>%
mutate(Share = count / sum(count)*100) %>%
select(-c(count))  %>%
pivot_wider(names_from = INCOME_DECILE,
values_from = "Share")
View(ACCESS_decile)
PARTICIPATE_decile = sipp_2023 %>%
filter(in_age_range =="yes") %>%
filter(PARTICIPATING !="Missing") %>%
filter(FULL_PART_TIME=="full time") %>%
mutate(INCOME_DECILE = ntile(TFTOTINC, 10)) %>%
group_by(PARTICIPATING, INCOME_DECILE) %>%
summarise(count = sum(WPFINWGT)) %>%
ungroup() %>%
group_by(INCOME_DECILE) %>%
mutate(Share = count / sum(count)*100) %>%
select(-c(count))%>%
pivot_wider(names_from = INCOME_DECILE,
values_from = "Share")
MATCH_decile = sipp_2023 %>%
filter(in_age_range =="yes") %>%
filter(MATCHING!="Missing") %>%
filter(FULL_PART_TIME=="full time") %>%
mutate(INCOME_DECILE = ntile(TFTOTINC, 10)) %>%
group_by(MATCHING, INCOME_DECILE) %>%
summarise(count = sum(WPFINWGT)) %>%
ungroup() %>%
group_by(INCOME_DECILE) %>%
mutate(Share = count / sum(count)*100) %>%
select(-c(count))%>%
pivot_wider(names_from = INCOME_DECILE,
values_from = "Share")
# export for plotting
write.xlsx(ACCESS_decile, paste(path_output, "ACCESS_decile.xlsx", sep = "/"))
write.xlsx(PARTICIPATE_decile, paste(path_output, "PARTICIPATE_decile.xlsx", sep = "/"))
write.xlsx(MATCH_decile, paste(path_output, "MATCH_decile.xlsx", sep = "/"))
earning_Deciles = sipp_2023 %>%
filter(in_age_range =="yes") %>%
filter(FULL_PART_TIME=="full time") %>%
mutate(INCOME_DECILE = ntile(TFTOTINC, 10)) %>%
ungroup() %>%
group_by(INCOME_DECILE) %>%
mutate(val = max(TFTOTINC,na.rm=TRUE)) %>%
select(val, INCOME_DECILE)
earning_Deciles = unique(earning_Deciles)
earning_Deciles
earning_Deciles = unique(earning_Deciles) %>% arrange(earning_Deciles)
earning_Deciles
earning_Deciles = sipp_2023 %>%
filter(in_age_range =="yes") %>%
filter(FULL_PART_TIME=="full time") %>%
mutate(INCOME_DECILE = ntile(TFTOTINC, 10)) %>%
ungroup() %>%
group_by(INCOME_DECILE) %>%
mutate(val = weighted.mean(TFTOTINC,na.rm=TRUE)) %>%
select(val, INCOME_DECILE)
earning_Deciles = unique(earning_Deciles) %>% arrange(earning_Deciles)
earning_Deciles
earning_Deciles = sipp_2023 %>%
filter(in_age_range =="yes") %>%
filter(FULL_PART_TIME=="full time") %>%
mutate(INCOME_DECILE = ntile(TFTOTINC, 10)) %>%
ungroup() %>%
group_by(INCOME_DECILE) %>%
mutate(val = weighted.mean(TFTOTINC,na.rm=TRUE)) %>%
select(val, INCOME_DECILE)
earning_Deciles = unique(earning_Deciles) %>% arrange(earning_Deciles)
View(earning_Deciles)
earning_Deciles = unique(earning_Deciles) %>% arrange(val)
earning_Deciles
earning_Deciles = unique(earning_Deciles) %>% arrange(INCOME_DECILE)
earning_Deciles
earning_Deciles = unique(earning_Deciles) %>%
arrange(INCOME_DECILE) %>%
mutate(val = val*12)
earning_Deciles
earning_Deciles = sipp_2023 %>%
filter(in_age_range =="yes") %>%
filter(FULL_PART_TIME=="full time") %>%
mutate(INCOME_DECILE = ntile(TFTOTINC, 10)) %>%
ungroup() %>%
group_by(INCOME_DECILE) %>%
mutate(val = median(TFTOTINC,na.rm=TRUE)) %>%
select(val, INCOME_DECILE)
earning_Deciles = unique(earning_Deciles) %>%
arrange(INCOME_DECILE) %>%
mutate(val = val*12)
earning_Deciles
earning_Deciles = sipp_2023 %>%
filter(in_age_range =="yes") %>%
filter(FULL_PART_TIME=="full time") %>%
mutate(INCOME_DECILE = ntile(TFTOTINC, 10)) %>%
ungroup() %>%
group_by(INCOME_DECILE) %>%
mutate(val = median(TFTOTINC,na.rm=TRUE)) %>%
select(val, INCOME_DECILE)
View(earning_Deciles)
earning_Deciles = unique(earning_Deciles) %>%
arrange(INCOME_DECILE) %>%
mutate(val = val*12)
earning_Deciles
